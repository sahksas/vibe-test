# 1. アーキテクチャ設計

## 1.1 システム全体構成

### 1.1.1 アーキテクチャ概要
```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   Web Browser   │────▶│      Nginx      │────▶│    Frontend     │
│                 │     │  (Reverse Proxy)│     │   (React App)   │
└─────────────────┘     └────────┬────────┘     └─────────────────┘
                                 │
                                 ▼
                        ┌─────────────────┐
                        │    Backend API   │
                        │   (Express.js)   │
                        └────────┬────────┘
                                 │
                    ┌────────────┴────────────┐
                    ▼                         ▼
           ┌─────────────────┐      ┌─────────────────┐
           │   PostgreSQL    │      │      Redis      │
           │   (Database)    │      │     (Cache)     │
           └─────────────────┘      └─────────────────┘
```

### 1.1.2 コンポーネント責務

1. **Nginx**
   - リバースプロキシ
   - 静的ファイル配信
   - SSL終端（本番環境）
   - ロードバランシング（将来対応）

2. **Frontend (React)**
   - ユーザーインターフェース
   - クライアントサイドルーティング
   - 状態管理（Redux）
   - API通信

3. **Backend API (Express)**
   - ビジネスロジック
   - データアクセス
   - 認証・認可
   - ファイル処理

4. **PostgreSQL**
   - 永続データストレージ
   - トランザクション管理
   - データ整合性保証

5. **Redis**
   - セッション管理
   - キャッシュ
   - リアルタイム通知（将来対応）

## 1.2 レイヤー構成

### 1.2.1 フロントエンドレイヤー構成
```
┌──────────────────────────────────────┐
│          Presentation Layer          │
│         (React Components)           │
├──────────────────────────────────────┤
│          State Management            │
│          (Redux Toolkit)             │
├──────────────────────────────────────┤
│           Service Layer              │
│          (API Clients)               │
├──────────────────────────────────────┤
│           Utility Layer              │
│    (Helpers, Constants, Types)       │
└──────────────────────────────────────┘
```

### 1.2.2 バックエンドレイヤー構成
```
┌──────────────────────────────────────┐
│         Controller Layer             │
│    (Request/Response Handling)       │
├──────────────────────────────────────┤
│          Service Layer               │
│       (Business Logic)               │
├──────────────────────────────────────┤
│       Repository Layer               │
│      (Data Access - Prisma)          │
├──────────────────────────────────────┤
│          Model Layer                 │
│     (Database Schema)                │
└──────────────────────────────────────┘
```

## 1.3 技術選定理由

### 1.3.1 フロントエンド
- **React**: コンポーネントベースで再利用性が高く、大規模アプリケーションに適している
- **TypeScript**: 型安全性により開発効率とコード品質が向上
- **Redux Toolkit**: 予測可能な状態管理と開発者体験の向上
- **Material-UI**: 統一されたUIコンポーネントで開発速度向上

### 1.3.2 バックエンド
- **Node.js**: JavaScriptでフロントエンドと言語統一、非同期処理に優れる
- **Express.js**: 軽量で柔軟、豊富なミドルウェアエコシステム
- **Prisma**: 型安全なORM、マイグレーション管理が容易
- **JWT**: ステートレスな認証でスケーラビリティ確保

### 1.3.3 データベース
- **PostgreSQL**: ACID準拠、JSON型サポート、高い信頼性
- **Redis**: 高速なインメモリデータストア、セッション管理に最適

### 1.3.4 インフラ
- **Docker**: 環境差異の解消、デプロイの簡素化
- **Nginx**: 高性能なWebサーバー、リバースプロキシ機能

## 1.4 セキュリティ設計

### 1.4.1 認証・認可
```typescript
// JWT構造
{
  "sub": "user_id",
  "email": "user@example.com",
  "role": "member",
  "iat": 1234567890,
  "exp": 1234654290
}
```

### 1.4.2 セキュリティ対策
1. **認証**
   - JWT によるトークンベース認証
   - リフレッシュトークンの実装
   - トークンの有効期限管理

2. **通信**
   - HTTPS強制（本番環境）
   - CORS設定による不正アクセス防止
   - CSRFトークンによる保護

3. **入力検証**
   - サーバーサイドバリデーション
   - SQLインジェクション対策（Prisma使用）
   - XSS対策（React自動エスケープ）

4. **アクセス制御**
   - ロールベースアクセス制御（RBAC）
   - APIレート制限
   - ファイルアップロード制限

### 1.4.3 データ保護
```typescript
// パスワードハッシュ化例
import bcrypt from 'bcrypt';

const hashPassword = async (password: string): Promise<string> => {
  const saltRounds = 10;
  return await bcrypt.hash(password, saltRounds);
};
```

## 1.5 パフォーマンス設計

### 1.5.1 キャッシュ戦略
1. **ブラウザキャッシュ**
   - 静的アセットの長期キャッシュ
   - Service Workerによるオフライン対応

2. **APIキャッシュ**
   - Redisによる頻繁アクセスデータのキャッシュ
   - キャッシュ無効化戦略

3. **データベースキャッシュ**
   - クエリ結果キャッシュ
   - コネクションプーリング

### 1.5.2 最適化方針
1. **フロントエンド**
   - コード分割とlazy loading
   - 画像最適化（WebP対応）
   - バンドルサイズ最小化

2. **バックエンド**
   - N+1問題の回避
   - 適切なインデックス設計
   - バッチ処理の活用

## 1.6 スケーラビリティ設計

### 1.6.1 水平スケーリング対応
- ステートレスなAPI設計
- セッションのRedis管理
- ファイルストレージの分離（将来対応）

### 1.6.2 垂直スケーリング対応
- リソース使用量の監視
- ボトルネック特定の仕組み
- 段階的なリソース追加

## 1.7 エラーハンドリング設計

### 1.7.1 エラー分類
1. **クライアントエラー（4xx）**
   - 400: Bad Request
   - 401: Unauthorized
   - 403: Forbidden
   - 404: Not Found
   - 422: Unprocessable Entity

2. **サーバーエラー（5xx）**
   - 500: Internal Server Error
   - 502: Bad Gateway
   - 503: Service Unavailable

### 1.7.2 エラーレスポンス形式
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "入力値が不正です",
    "details": [
      {
        "field": "email",
        "message": "有効なメールアドレスを入力してください"
      }
    ]
  }
}
```

## 1.8 ログ設計

### 1.8.1 ログレベル
- **ERROR**: システムエラー、例外
- **WARN**: 警告、非推奨機能の使用
- **INFO**: 重要なイベント（ログイン、データ変更）
- **DEBUG**: デバッグ情報（開発環境のみ）

### 1.8.2 ログ形式
```json
{
  "timestamp": "2024-01-01T00:00:00.000Z",
  "level": "INFO",
  "service": "backend",
  "userId": "123",
  "requestId": "abc-def-ghi",
  "message": "User logged in",
  "metadata": {
    "ip": "192.168.1.1",
    "userAgent": "Mozilla/5.0..."
  }
}
```